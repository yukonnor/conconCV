/* NOTES ABOUT SKETCH:
 * Code to support a CV/Gate control surface with: 
 * - two 'trigger' controls (X/Y) and one mono output for each
 * - two 'cv level' controls (A/B) and one mono output for each
 * -- 'high' level cv is good around ~4.5V (wobble bug peaks 9V)
 *
 * Sliders (A & B): 
 * - Sets external CV of 0V to 5V based on finger position (gradient)
 * - Maintains level of A/B when removing finger
 * - Indicates level of A/B sliders via A/B LED brightness
 * 
 * Gates (X & Y):
 * - Sets external CV: 0V or 4.8V (on-off) based on whether or not finger is touching pad
 * 
 * TODO:
 * - Add code to "maintain" values when finger leaves on A & B sensors OR use sample and hold button
 * -- if fader is 'touched' (reads > low value), reads values in real time
 * -- if fader is 'not_touched', sets value to last read value
 * -- Add new global 'smooth maintain' variables if needed
 * - try to wire a and b together to save pinnnnns
 * - debounce push buttons 
 * - ergonimics
 * - solder protoboard of what's currently breadboarded
 * - figue out case design
 * 
 * 
 * NOTES ABOUT CapacitiveSensor:
 * Uses a high value resistor e.g. 10 megohm between send pin and receive pin
 * Resistor effects sensitivity, experiment with values, 50 kilohm - 50 megohm. Larger resistor values yield larger sensor values.
 * Receive pin is the sensor pin - try different amounts of foil/metal on this pin
 * Best results are obtained if sensor foil and wire is covered with an insulator such as paper or plastic sheet
 */
#include <Wire.h> //I2C for DACs
#include <Adafruit_MCP4725.h> //I2C for DACs
#include <CapacitiveSensor.h>

Adafruit_MCP4725 dac; //rename library
#define DAC_RESOLUTION    (8) //8-bit resolution

CapacitiveSensor   cs_x = CapacitiveSensor(2,3);    // 470K resistor between pins 2 & 4, pin 4 is sensor pin, add wire, foil
CapacitiveSensor   cs_y = CapacitiveSensor(2,4);    // 470K resistor between pins 2 & 5, pin 5 is sensor pin, add wire, foil
CapacitiveSensor   cs_a = CapacitiveSensor(5,6);    // 300K resistor between pins 5 & 6, pin 6 is sensor pin, add wire, foil
CapacitiveSensor   cs_b = CapacitiveSensor(7,8);    // 300K resistor between pins 8 & 7, pin 7 is sensor pin

//Define LED Variables
const int ledPin_A = 9;         // the PWM pin the LED for A is attached to
const int ledPin_B = 10;        // the PWM pin the LED for A is attached to
int brightness_A = 0;           //  how bright the LED for A is. Should be between 0 - 255
int brightness_B = 0;  

//X & Y Gate Pins
const int xPin = 12;
const int yPin = 13;

const int button_a_Pin = 0;
int button_a_State = 0; //0 if off, 1 is on
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers

unsigned int dac_0_out = 0;
unsigned int dac_1_out = 0;

//Define Smoothing Variables
const int numReadings = 100;       // smoothness time: 10 immediate, 50 med, 100 long (yet still playable)
int readings_a[numReadings];      // array of the readings from the analog input
int readings_b[numReadings]; 
int readIndex_a = 0;              // the index of the current reading
int readIndex_b = 0;
int total_a = 0;                  // the running total
int total_b = 0; 
int average_reading_a = 0;        // the average
int average_reading_b = 0; 

void setup()                    
{
  // declare LED pins and XY Gate pins to be outputs:
  pinMode(ledPin_A, OUTPUT);
  pinMode(ledPin_B, OUTPUT);
  pinMode(xPin, OUTPUT);
  pinMode(yPin, OUTPUT);
  pinMode(button_a_Pin, INPUT_PULLUP);

  //Smoothing - initialize all the readings to 0:
  for (int thisReading = 0; thisReading < numReadings; thisReading++) {
      readings_a[thisReading] = 0;
  }
  
  for (int thisReading = 0; thisReading < numReadings; thisReading++) {
      readings_b[thisReading] = 0;
  }

  Serial.begin(9600);

  dac.begin(0x60);
  dac.setVoltage(0,false);
  dac.begin(0x61);
  dac.setVoltage(0,false);

}

void loop()                    
{
    //Define CapSense variables and readings  
    long start = millis();
    long cap_reading_x =  cs_x.capacitiveSensor(30); //on-off based on logic below
    long cap_reading_y =  cs_y.capacitiveSensor(30); //on-off based on logic below
    int dirty_reading_a =  cs_a.capacitiveSensor(30); //0 - 600 with 470K resistor
    int dirty_reading_b =  cs_b.capacitiveSensor(30); //0 - 680 with 470K resistor (maybe try to decrease?)

    int button_a_Read = digitalRead(button_a_Pin); 
    
    //On off Logic: if off and pressed, turn on
    if (button_a_Read == LOW && button_a_State == 0 &&((millis() - lastDebounceTime) > debounceDelay)) {
        button_a_State = 1;
        lastDebounceTime = millis();
       }
       else if (button_a_Read == LOW && button_a_State == 1 && ((millis() - lastDebounceTime) > debounceDelay)){
        button_a_State = 0;
        lastDebounceTime = millis();
       }

    //IF "MAINTAIN" Button if OFF, Record A values constantly
    //IF "MAINTAIN" Button is ON, Keep last touched value using "Smooth_Maintain" function
    if (button_a_State == 0) {
      int cap_reading_a = Smooth_A(dirty_reading_a); //A reading is now smoothed
    }
    else {
      int cap_reading_a = Smooth_Maintain_A(dirty_reading_a, 80, 10); //A value is now maintained if finger released
    }
    
    
    int cap_reading_b = Smooth_B(dirty_reading_b); //B reading is now smoothed
    cap_reading_b = max(cap_reading_b, 35); //hacky way to 'eliminate' bleeding
    //when a was touched, b was going up to ~35. This makes 35 the '0 value for b (along with mapping functions below)
    //any level below that was bareley noticibale anyways.  

    //Logic for X & Y On Off
    cap_reading_x = On_Off_Threshold(cap_reading_x, 140); //if x is > 140, it is HIGH. Else LOW.
    cap_reading_y = On_Off_Threshold(cap_reading_y, 140); 

    //if S&H button off, set dac values to map to current capsense readings
    //if S&H button on, set dac value to last value read
    
    
    dac.begin(0x60);
    dac.setVoltage(dac_0_out, false);
    dac.begin(0x61);
    dac.setVoltage(dac_1_out, false);


    //SET THEM GATE OUTPUTS
    digitalWrite(xPin, cap_reading_x);
    digitalWrite(yPin, cap_reading_y); 
    
    //light up those LEDs!
    analogWrite(ledPin_A, brightness_A);
    analogWrite(ledPin_B, brightness_B);
    // end LEDS
    

    /* 
    //Serial.print("Millis = ");
    //Serial.print(millis() - start);           // check on performance in milliseconds
    //Serial.print("Button State = ");
    //Serial.print(buttonState1);              
    //Serial.print("\t");
    //Serial.print("Button Read = ");
    //Serial.print(buttonRead1);              
    //Serial.println("\t");
    Serial.print("\t");
    Serial.print("X Touch = ");
    Serial.print(cap_reading_x);              // print sensor X
    Serial.print("\t");
    Serial.print("Y Touch = ");
    Serial.print(cap_reading_y);              // print sensor Y
    Serial.print("\t");
    Serial.print("Dirty A = ");
    Serial.print(dirty_reading_a);              // print sensor Y
    Serial.print("\t");
    Serial.print("A Touch = ");
    Serial.print(cap_reading_a);              // print sensor A
    Serial.print("\t");   
    Serial.print("Brightness A = ");
    Serial.print(brightness_A);               // print brightness
    Serial.print("\t");
    Serial.print("B Touch = ");
    Serial.print(cap_reading_b);              // print sensor B
    Serial.print("\t");
    Serial.print("Brightness B = ");
    Serial.print(brightness_B);
    Serial.println("\t");
*/
       
} //end Loop

int Smooth_A(int dirty_reading) {
  //Be sure to include global variables and intializer in setup()
  
  // subtract the last reading:
  total_a = total_a - readings_a[readIndex_a];
  // read from the sensor:
  readings_a[readIndex_a] = dirty_reading;
  // add the reading to the total:
  total_a = total_a + readings_a[readIndex_a];
  // advance to the next position in the array:
  readIndex_a = readIndex_a + 1;

  // if we're at the end of the array...
  if (readIndex_a >= numReadings) {
    // ...wrap around to the beginning:
    readIndex_a = 0;
    }
  // calculate the average:
  average_reading_a = total_a / numReadings;

  return average_reading_a;

} //end Smooth_A


int Smooth_B(int dirty_reading) {
  //Be sure to include global variables and intializer in setup()
  
  // subtract the last reading:
  total_b = total_b - readings_b[readIndex_b];
  // read from the sensor:
  readings_b[readIndex_b] = dirty_reading;
  // add the reading to the total:
  total_b = total_b + readings_b[readIndex_b];
  // advance to the next position in the array:
  readIndex_b = readIndex_b + 1;

  // if we're at the end of the array...
  if (readIndex_b >= numReadings) {
    // ...wrap around to the beginning:
    readIndex_b = 0;
    }
  // calculate the average:
  average_reading_b = total_b / numReadings;

  return average_reading_b;

} //end Smooth_B


//Use this function to maintain the 'last touched value' if finger is removed
int Smooth_Maintain_A(int dirty_reading, int hold_above_value, int touch_threshold) {  //used 80 and 10
  //Be sure to include global variables and intializer in setup()

  // subtract the last reading:
  total_a = total_a - readings_a[readIndex_a];
  // read from the sensor:
  if (dirty_reading > hold_above_value ) {  //if above this touched value, keep at that value when sensor released
  readings_a[readIndex_a] = dirty_reading;}
  //if sensor is being TOUCHED (dirty measures over 10) below the min_a_value, bring average down to 0
  else if (dirty_reading > touch_threshold) {  //if it's touched above the 'touch_threshold' but below the 'hold_above_value', let fall to 0
  readings_a[readIndex_a] = 0;  
  }
  // add the reading to the total:
  total_a = total_a + readings_a[readIndex_a];
  // advance to the next position in the array:
  readIndex_a = readIndex_a + 1;

  // if we're at the end of the array...
  if (readIndex_a >= numReadings) {
    // ...wrap around to the beginning:
    readIndex_a = 0;
    }
  // calculate the average:
  average_reading_a = total_a / numReadings;

  return average_reading_a;

} //end Smooth_Maintain_A 

boolean On_Off_Threshold(int on_off, int threshold) {

      if (on_off < threshold){
        on_off = LOW;
        }
        else {
        on_off = HIGH;  
        }

      return on_off;  
}
